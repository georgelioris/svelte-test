var app=function(){"use strict";function e(){}function t(e){return e()}function o(){return Object.create(null)}function n(e){e.forEach(t)}function r(e){return"function"==typeof e}function i(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function a(e,t){e.appendChild(t)}function s(e,t,o){e.insertBefore(t,o||null)}function c(e){e.parentNode.removeChild(e)}function d(e){return document.createElement(e)}function l(){return e=" ",document.createTextNode(e);var e}let u;function h(e){u=e}const m=[],p=[],f=[],g=[],y=Promise.resolve();let w=!1;function b(e){f.push(e)}let x=!1;const v=new Set;function k(){if(!x){x=!0;do{for(let e=0;e<m.length;e+=1){const t=m[e];h(t),$(t.$$)}for(m.length=0;p.length;)p.pop()();for(let e=0;e<f.length;e+=1){const t=f[e];v.has(t)||(v.add(t),t())}f.length=0}while(m.length);for(;g.length;)g.pop()();w=!1,x=!1,v.clear()}}function $(e){if(null!==e.fragment){e.update(),n(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(b)}}const T=new Set;function M(e,t){e&&e.i&&(T.delete(e),e.i(t))}function H(e,o,i){const{fragment:a,on_mount:s,on_destroy:c,after_update:d}=e.$$;a&&a.m(o,i),b(()=>{const o=s.map(t).filter(r);c?c.push(...o):n(o),e.$$.on_mount=[]}),d.forEach(b)}function L(e,t){const o=e.$$;null!==o.fragment&&(n(o.on_destroy),o.fragment&&o.fragment.d(t),o.on_destroy=o.fragment=null,o.ctx=[])}function C(e,t){-1===e.$$.dirty[0]&&(m.push(e),w||(w=!0,y.then(k)),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function _(t,r,i,a,s,d,l=[-1]){const m=u;h(t);const p=r.props||{},f=t.$$={fragment:null,ctx:null,props:d,update:e,not_equal:s,bound:o(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(m?m.$$.context:[]),callbacks:o(),dirty:l};let g=!1;if(f.ctx=i?i(t,p,(e,o,...n)=>{const r=n.length?n[0]:o;return f.ctx&&s(f.ctx[e],f.ctx[e]=r)&&(f.bound[e]&&f.bound[e](r),g&&C(t,e)),o}):[],f.update(),g=!0,n(f.before_update),f.fragment=!!a&&a(f.ctx),r.target){if(r.hydrate){const e=function(e){return Array.from(e.childNodes)}(r.target);f.fragment&&f.fragment.l(e),e.forEach(c)}else f.fragment&&f.fragment.c();r.intro&&M(t.$$.fragment),H(t,r.target,r.anchor),k()}h(m)}class j{$destroy(){L(this,1),this.$destroy=e}$on(e,t){const o=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return o.push(t),()=>{const e=o.indexOf(t);-1!==e&&o.splice(e,1)}}$set(){}}function z(t){let o,n,r,i,u,h,m,p,f,g,y,w,b,x,v,k,$,T,M,H,L,C,_,j,z,E,q,O,P,S,I,U,F,B,W,N,A,R,X,Y,D,G,J,K,Q,V,Z,ee,te,oe,ne,re,ie,ae,se,ce,de,le,ue,he,me,pe,fe,ge,ye,we,be,xe,ve,ke,$e,Te,Me,He,Le,Ce,_e,je,ze,Ee,qe,Oe,Pe,Se,Ie,Ue,Fe,Be,We,Ne,Ae,Re,Xe,Ye,De,Ge,Je,Ke,Qe,Ve,Ze,et,tt,ot,nt,rt,it,at,st,ct,dt,lt,ut,ht,mt,pt,ft,gt,yt,wt,bt,xt,vt,kt,$t,Tt,Mt,Ht,Lt,Ct,_t,jt,zt,Et,qt,Ot,Pt,St,It,Ut,Ft,Bt,Wt;return{c(){o=d("h2"),o.textContent="Improving productivity in the terminal with pipes",n=l(),r=d("p"),r.innerHTML="If you do any kind of development, the terminal is probably part of your\nworkflow, and although some tasks are relatively painless out of the box - like\nmanaging software packages - others can take time to adjust to. But doing\nthings in the terminal isn&#39;t supposed to be hard, on the contrary, it&#39;s\nliberating, it gets everything out of the way so you can interact with the\ncomputer in the most direct way. By using <em>pipes</em> you can hopefully remove some\nfriction and make the experience more enjoyable. Even if the majority\nof your work is done outside of the terminal, you can still reap the benefits\nof utilizing command line tools to speed up common tasks. Without any shell\nscripting knowledge, you can get a lot of functionality out of combining\ncommands with preexisting tools on your system.",i=l(),u=d("hr"),h=l(),m=d("h3"),m.textContent="Unix philosophy",p=l(),f=d("p"),f.innerHTML='Unix tools are a very powerful set of low level programs that follow the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a>,\nand provide you with  very powerful abstractions. In practice this\ntranslates to a couple of things:',g=l(),y=d("ul"),y.innerHTML="<li>Each program does one thing really well</li> \n<li>The output of one program can be the input of another program</li>",w=l(),b=d("p"),b.innerHTML="A shell allows the use of <strong>stdout</strong> as <strong>stdin</strong> with the use of the pipe <code>|</code> operator.",x=l(),v=d("blockquote"),v.innerHTML='<p>Unix programs use <a href="https://en.wikipedia.org/wiki/Standard_streams">Standard streams</a>,\nbut to simplify things we will refer to <strong><em>stdout</em></strong> as what the program outputs\nand <strong><em>stdin</em></strong> to the data the program on right side of the pipe operator receives.</p>',k=l(),$=d("p"),$.innerHTML="Some of those tools are the familiar <code>cd</code>, <code>cat</code>, <code>grep</code>, <code>echo</code>, <code>mkdir</code> etc, but there are many more,\nand since most cli tools follow the same logic we have plenty of options. If you are aware of the pipe\noperator, it&#39;s certain you have encountered the following",T=l(),M=d("pre"),H=d("code"),H.textContent="cat file | grep pattern",L=l(),C=d("p"),C.innerHTML="This is quite underwhelming and also suboptimal. Using <code>cat</code> here is redundant,\nsince <code>grep</code> can take file/s as argument/s and while it&#39;s fine if it happens in\nyour terminal, it should be avoided when writing scripts.",_=l(),j=d("p"),j.innerHTML="While getting a stream of data and piping it into a <code>grep</code> is pretty straight\nforward, it&#39;s not very exciting. By utilizing <em>pipes</em>, you can do more with tools\nyou already use, with very little overhead.  Some more interesting common use\ncases for <em>pipes</em> are using interfaces to make dynamic selections, executing\nconditionally, feeding data to commands that don&#39;t read from <strong><em>stdin</em></strong>.",z=l(),E=d("hr"),q=l(),O=d("h3"),O.textContent="Leveraging pipes",P=l(),S=d("p"),S.textContent="Navigating to a project's directory is a very common operation, and while tab\ncompletion is great, we can make it virtually effortless by using a fuzzy\nfinder. Our goal is to create a fuzzy matched list with our project directories\nto select from.",I=l(),U=d("p"),U.innerHTML="Let&#39;s assume all our projects are located at inside the <em>code</em> directory of our home folder.",F=l(),B=d("p"),B.textContent="First we need to generate a list of our directory paths.",W=l(),N=d("p"),N.innerHTML="<strong>du</strong> - summarizes disk usage of the set of FILEs, recursively for directories<br>\nWithout the <code>-a</code> flag it will only list directories. We make sure to exclude\nthe <em>node_modules</em> and hidden folders (such as .git) to avoid flooding our list\nwith unwanted results, this also improves the speed of our command.<br>",A=l(),R=d("pre"),X=d("code"),X.textContent='$ du ~/code --exclude={".*","node_*"}\n\n5584 /home/user/code/Project1/\n12 /home/user/code/Project1/src\n4980 /home/user/code/Project2/\n4    /home/user/code/Project2/src\n...',Y=l(),D=d("blockquote"),D.innerHTML="<p>For lengthier ignore patterns you can provide a <em>.ignore</em> file with the <code>--exclude-from=&quot;path/to/.ignore&quot;</code> option.</p>",G=l(),J=d("p"),J.textContent="Since we only need the paths we need to format our data.",K=l(),Q=d("p"),Q.innerHTML="<strong>cut</strong> - removes sections from each line of files<br>\nwith the <code>-f2-</code> option it will print only the second field of each line, so just the directory paths.",V=l(),Z=d("pre"),ee=d("code"),ee.textContent='$ du ~/code --exclude={".*","node_*"} | cut -f2-\n\n/home/user/code/Project1/\n/home/user/code/Project1/src\n/home/user/code/Project2/\n/home/user/code/Project2/src\n...',te=l(),oe=d("p"),oe.innerHTML="We could use that data as is but we can make it look cleaner by removing the <em>$HOME</em> path.",ne=l(),re=d("p"),re.innerHTML="<strong>sed</strong> - stream editor for filtering and transforming text<br>\nFor any operations on strings this is quite handy, allowing you to perform even\nadvanced <em>regex</em> with the <code>-E</code> flag.",ie=l(),ae=d("pre"),se=d("code"),se.textContent='$ du ~/code --exclude={".*","node_*",misc,public} | cut -f2- | sed "s|$HOME/||"\n\ncode/Project1/\ncode/Project1/src\ncode/Project2/\ncode/Project2/src\n...',ce=l(),de=d("p"),de.textContent="Now that our data is ready we need a menu to select from.",le=l(),ue=d("pre"),he=d("code"),he.textContent='du ~/code --exclude={".*","node_*"} | cut -f2- | sed "s|$HOME/||"| fzf +m',me=l(),pe=d("p"),pe.innerHTML='<strong><a href="https://github.com/junegunn/fzf">fzf</a></strong> - a command-line fuzzy finder<br>\nThis will provide us the fuzzy list to select a directory from. Any selection we make will\nget printed to <strong><em>stdout</em></strong>, ready for our next command to read.\nThe <code>+m</code> option disables multiline selection.',fe=l(),ge=d("p"),ge.innerHTML="To change directory we need to give our selection to <code>cd</code>, but before we do that we need to prepend\nthe <em>$HOME</em> path.",ye=l(),we=d("pre"),be=d("code"),be.textContent='du ~/code --exclude={".*","node_*",misc,public} | cut -f2- | sed "s|$HOME/||" | fzf +m | sed "s|^|$HOME/|"',xe=l(),ve=d("p"),ve.innerHTML="Unlike the previous commands <code>cd</code> cannot read from <strong><em>stdin</em></strong> (we&#39;ll get a bit into why later) so we will\nuse command substitution, replacing the <em>dir</em> name with our pipe. Anything\ninside <code>&quot;$(...)&quot; </code>(or <code>`...`</code>) will get evaluated (executed) first, and <code>cd</code> will run after.",ke=l(),$e=d("pre"),Te=d("code"),Te.textContent='cd "$(du ~/code --exclude={".*","node_*",misc,public} | cut -f2- | sed "s|$HOME/||" | fzf +m | sed "s|^|$HOME/|")"',Me=l(),He=d("p"),He.textContent="Since this is intended to be used frequently we can extract that logic to a\nfunction inside our shell's .rc file (.bashrc/.zshrc)",Le=l(),Ce=d("pre"),_e=d("code"),_e.textContent='cf() { cd "$(du ~/code --exclude={".*","node_*",misc,public} | cut -f2- | sed "s|$HOME/||" | fzf +m | sed "s|^|$HOME/|")" ;}',je=l(),ze=d("p"),ze.innerHTML="<strong>cf</strong> - is the name of the function and how we access it from the shell",Ee=l(),qe=d("p"),qe.innerHTML='<img src="./demo.gif" alt="Function demonstration" title="Function demonstration">',Oe=l(),Pe=d("hr"),Se=l(),Ie=d("p"),Ie.textContent="Following the same idea let's create a similar pipe for changing git branches.",Ue=l(),Fe=d("p"),Fe.textContent="Fist we need to check if we are in a valid git directory.",Be=l(),We=d("p"),We.innerHTML="This can be achieved executing our pipe only if <code>git branch</code> (or  <code>git status</code>)\nsucceeds.  Since we don&#39;t care about the actual output of that command, we will\ndiscard it by redirecting it to  <code>/dev/null</code> In case of an error, the message\nstill gets printed since we only redirected <strong><em>stdout</em></strong> not <strong><em>stderr</em></strong>.",Ne=l(),Ae=d("blockquote"),Ae.innerHTML="<p>To discard the error message as well, use <code>command &gt; /dev/null 2&gt;&amp;1</code></p>",Re=l(),Xe=d("pre"),Ye=d("code"),Ye.textContent="git branch > /dev/null && git branch",De=l(),Ge=d("p"),Ge.innerHTML="To make the output of git branch usable we need to treat individual non-empty\nlines as input arguments and print that to <strong><em>stdout</em></strong> for our next command to\nread. <code>xargs -L 1</code> takes care of the first part and <code>echo</code> of the latter.",Je=l(),Ke=d("p"),Ke.innerHTML="<strong>xargs</strong> - build and execute command lines from standard input<br>\nSome commands (like <code>echo</code>) cannot read from <strong><em>stdin</em></strong>, in that case <code>xargs</code>\nwill read from <strong><em>stdin</em></strong> and execute the command we give it with that input.",Qe=l(),Ve=d("blockquote"),Ve.innerHTML="<p>The reason we did not use <code>xargs</code> for <code>cd</code>, is because <code>xargs</code> runs commands in a\nsubprocess and changes in a subprocess do not get propagated to the parent\nprocess.</p>",Ze=l(),et=d("pre"),tt=d("code"),tt.textContent="$ git branch > /dev/null && git branch | xargs -L 1 echo\n\n* master\nfeature\ntesting",ot=l(),nt=d("p"),nt.innerHTML='Now we can supply our interface as before. Instead of <code>fzf</code> we could use any\nequivalent tool of our choice, even a graphical one like <strong><a href="https://tools.suckless.org/dmenu/">dmenu</a></strong> or\n<strong><a href="https://github.com/davatorium/rofi">rofi</a></strong>.',rt=l(),it=d("pre"),at=d("code"),at.textContent="git branch > /dev/null && git branch | xargs -L 1 echo | fzf --reverse",st=l(),ct=d("p"),ct.innerHTML="You may have noticed that the asterisk is visible in our interface. That&#39;s because\nit&#39;s a useful visual indicator when changing branches. To avoid any trouble, we will\nremove it before calling <code>git checkout</code>.",dt=l(),lt=d("pre"),ut=d("code"),ut.textContent='git branch > /dev/null && git branch | xargs -L 1 echo | fzf --reverse | sed "s/.* //"',ht=l(),mt=d("p"),mt.innerHTML="Finally we need to call <code>git checkout</code> on our selection, Using <code>xargs</code> once again.\nThe <code>-r</code> option will prevent execution on empty input.",pt=l(),ft=d("pre"),gt=d("code"),gt.textContent='git branch > /dev/null && git branch | xargs -L 1 echo | fzf --reverse | sed "s/.* //" | xargs -r git checkout',yt=l(),wt=d("hr"),bt=l(),xt=d("h3"),xt.textContent="POSIX Shell syntax",vt=l(),kt=d("p"),kt.innerHTML='Instead of a function you may also put your pipe in a script file. When writing\nscripts that are intended to be run on other systems, you may want to avoid\n<a href="https://mywiki.wooledge.org/Bashism">bashisms</a>. For portability, make it POSIX compliant as all Unices have at\nleast one shell called <strong>sh</strong> (usually at <em>/bin/sh</em>) that can interpret that syntax.\nIf your script does depend on bash make sure to use the appropriate shebang\n(<code>#!/usr/bin/env bash</code>).  You can lint your scripts with <a href="https://github.com/koalaman/shellcheck"> shellcheck\n</a> which also provides useful suggestions.',$t=l(),Tt=d("hr"),Mt=l(),Ht=d("h3"),Ht.textContent="Which is faster?",Lt=l(),Ct=d("p"),Ct.textContent="There are multiple ways that achieve the same result but some are more optimal\nthan others.  Usually commands take milliseconds to execute so it's hard to\ntell which iteration is faster. It can also be hard to determine how adding\nanother command to your pipe affects performance. A quick way to check the\nspeed of a command is by running it multiple times and measuring the total time\nto completion.",_t=l(),jt=d("pre"),zt=d("code"),zt.textContent="$ time (\nfor x in $(seq 100 ); do\ncommand > /dev/null\ndone )\n\n7.88s user 3.26s system 120% cpu 9.266 total",Et=l(),qt=d("blockquote"),qt.innerHTML="<p>Redirecting output to <code>/dev/null</code> so we don&#39;t flood the terminal</p>",Ot=l(),Pt=d("hr"),St=l(),It=d("h3"),It.textContent="More tools",Ut=l(),Ft=d("p"),Ft.textContent="The above examples only scratch the surface of what possible. The demonstrated model,\nhopefully provides some ideas on how you can integrate your tools with other commands.\nThere are plenty more common operations you may want for your workflow. Below I've compiled\na short list of programs you may find interesting.",Bt=l(),Wt=d("ul"),Wt.innerHTML='<li><code>awk</code> for more complicated field selections and pattern scanning</li> \n<li><code>rsync</code> for remote and local file copying</li> \n<li><a href="https://curl.haxx.se/"> curl </a> for transferring data with URLs</li> \n<li><a href="https://github.com/BurntSushi/ripgrep"> ripgrep </a> recursively search for a pattern in files of a directory</li> \n<li><a href="https://github.com/sharkdp/fd"> fd </a> to search for directories and files</li> \n<li><a href="https://github.com/sharkdp/bat"> bat </a> cat but with syntax highlighting</li> \n<li><a href="http://eradman.com/entrproject/"> entr </a> to run arbitrary commands when files change</li> \n<li><a href="https://github.com/mptre/yank">yank</a> to selectively copy terminal output to clipboard</li> \n<li><a href="https://www.ffmpeg.org/">ffmpeg</a> video converter</li> \n<li><a href="https://mpv.io/">mpv</a> media player than can read video data from <strong><em>stdin</em></strong> and URLs</li> \n<li><a href="https://imagemagick.org/">imagemagick</a> edit, crate or modify images</li>'},m(e,t){s(e,o,t),s(e,n,t),s(e,r,t),s(e,i,t),s(e,u,t),s(e,h,t),s(e,m,t),s(e,p,t),s(e,f,t),s(e,g,t),s(e,y,t),s(e,w,t),s(e,b,t),s(e,x,t),s(e,v,t),s(e,k,t),s(e,$,t),s(e,T,t),s(e,M,t),a(M,H),s(e,L,t),s(e,C,t),s(e,_,t),s(e,j,t),s(e,z,t),s(e,E,t),s(e,q,t),s(e,O,t),s(e,P,t),s(e,S,t),s(e,I,t),s(e,U,t),s(e,F,t),s(e,B,t),s(e,W,t),s(e,N,t),s(e,A,t),s(e,R,t),a(R,X),s(e,Y,t),s(e,D,t),s(e,G,t),s(e,J,t),s(e,K,t),s(e,Q,t),s(e,V,t),s(e,Z,t),a(Z,ee),s(e,te,t),s(e,oe,t),s(e,ne,t),s(e,re,t),s(e,ie,t),s(e,ae,t),a(ae,se),s(e,ce,t),s(e,de,t),s(e,le,t),s(e,ue,t),a(ue,he),s(e,me,t),s(e,pe,t),s(e,fe,t),s(e,ge,t),s(e,ye,t),s(e,we,t),a(we,be),s(e,xe,t),s(e,ve,t),s(e,ke,t),s(e,$e,t),a($e,Te),s(e,Me,t),s(e,He,t),s(e,Le,t),s(e,Ce,t),a(Ce,_e),s(e,je,t),s(e,ze,t),s(e,Ee,t),s(e,qe,t),s(e,Oe,t),s(e,Pe,t),s(e,Se,t),s(e,Ie,t),s(e,Ue,t),s(e,Fe,t),s(e,Be,t),s(e,We,t),s(e,Ne,t),s(e,Ae,t),s(e,Re,t),s(e,Xe,t),a(Xe,Ye),s(e,De,t),s(e,Ge,t),s(e,Je,t),s(e,Ke,t),s(e,Qe,t),s(e,Ve,t),s(e,Ze,t),s(e,et,t),a(et,tt),s(e,ot,t),s(e,nt,t),s(e,rt,t),s(e,it,t),a(it,at),s(e,st,t),s(e,ct,t),s(e,dt,t),s(e,lt,t),a(lt,ut),s(e,ht,t),s(e,mt,t),s(e,pt,t),s(e,ft,t),a(ft,gt),s(e,yt,t),s(e,wt,t),s(e,bt,t),s(e,xt,t),s(e,vt,t),s(e,kt,t),s(e,$t,t),s(e,Tt,t),s(e,Mt,t),s(e,Ht,t),s(e,Lt,t),s(e,Ct,t),s(e,_t,t),s(e,jt,t),a(jt,zt),s(e,Et,t),s(e,qt,t),s(e,Ot,t),s(e,Pt,t),s(e,St,t),s(e,It,t),s(e,Ut,t),s(e,Ft,t),s(e,Bt,t),s(e,Wt,t)},p:e,i:e,o:e,d(e){e&&c(o),e&&c(n),e&&c(r),e&&c(i),e&&c(u),e&&c(h),e&&c(m),e&&c(p),e&&c(f),e&&c(g),e&&c(y),e&&c(w),e&&c(b),e&&c(x),e&&c(v),e&&c(k),e&&c($),e&&c(T),e&&c(M),e&&c(L),e&&c(C),e&&c(_),e&&c(j),e&&c(z),e&&c(E),e&&c(q),e&&c(O),e&&c(P),e&&c(S),e&&c(I),e&&c(U),e&&c(F),e&&c(B),e&&c(W),e&&c(N),e&&c(A),e&&c(R),e&&c(Y),e&&c(D),e&&c(G),e&&c(J),e&&c(K),e&&c(Q),e&&c(V),e&&c(Z),e&&c(te),e&&c(oe),e&&c(ne),e&&c(re),e&&c(ie),e&&c(ae),e&&c(ce),e&&c(de),e&&c(le),e&&c(ue),e&&c(me),e&&c(pe),e&&c(fe),e&&c(ge),e&&c(ye),e&&c(we),e&&c(xe),e&&c(ve),e&&c(ke),e&&c($e),e&&c(Me),e&&c(He),e&&c(Le),e&&c(Ce),e&&c(je),e&&c(ze),e&&c(Ee),e&&c(qe),e&&c(Oe),e&&c(Pe),e&&c(Se),e&&c(Ie),e&&c(Ue),e&&c(Fe),e&&c(Be),e&&c(We),e&&c(Ne),e&&c(Ae),e&&c(Re),e&&c(Xe),e&&c(De),e&&c(Ge),e&&c(Je),e&&c(Ke),e&&c(Qe),e&&c(Ve),e&&c(Ze),e&&c(et),e&&c(ot),e&&c(nt),e&&c(rt),e&&c(it),e&&c(st),e&&c(ct),e&&c(dt),e&&c(lt),e&&c(ht),e&&c(mt),e&&c(pt),e&&c(ft),e&&c(yt),e&&c(wt),e&&c(bt),e&&c(xt),e&&c(vt),e&&c(kt),e&&c($t),e&&c(Tt),e&&c(Mt),e&&c(Ht),e&&c(Lt),e&&c(Ct),e&&c(_t),e&&c(jt),e&&c(Et),e&&c(qt),e&&c(Ot),e&&c(Pt),e&&c(St),e&&c(It),e&&c(Ut),e&&c(Ft),e&&c(Bt),e&&c(Wt)}}}class E extends j{constructor(e){super(),_(this,e,null,z,i,{})}}function q(t){let o,n,r,i;return r=new E({}),{c(){var e;o=d("markup"),n=d("main"),(e=r.$$.fragment)&&e.c()},m(e,t){s(e,o,t),a(o,n),H(r,n,null),i=!0},p:e,i(e){i||(M(r.$$.fragment,e),i=!0)},o(e){!function(e,t,o,n){if(e&&e.o){if(T.has(e))return;T.add(e),(void 0).c.push(()=>{T.delete(e),n&&(o&&e.d(1),n())}),e.o(t)}}(r.$$.fragment,e),i=!1},d(e){e&&c(o),L(r)}}}function O(e,t,o){let{name:n}=t;return n="george lioris",e.$set=e=>{"name"in e&&o(0,n=e.name)},[n]}return new class extends j{constructor(e){super(),_(this,e,O,q,i,{name:0})}}({target:document.body,props:{name:"world"}})}();
//# sourceMappingURL=bundle.js.map
